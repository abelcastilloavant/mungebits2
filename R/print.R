## Elegant printing is hard work! This file contains some helpers
## to make outputting mungebits objects beautiful.
# Print a `mungebit` object.
print_mungebit <- function(x, ..., indent = 0L) {
  prefix <- paste(rep("  ", indent), collapse = "")
  cat(sep = "", prefix, crayon::green("Mungebit"), " with:\n")
  print_mungebit_function(x, "train",   "green",  indent + 1L, ...)
  print_mungebit_function(x, "predict", "yellow", indent + 1L, ...)
}

print_mungebit_function <- function(bit, type, color, indent, ..., full = FALSE) {
  prefix <- paste(rep("  ", indent), collapse = "")
  ## Either `bit$train_function()` or `bit$predict_function()`.
  fn <- bit[[paste0(type, "_function")]]()
  ## A dynamic way to fetch the color palette from the crayon package.
  style <- getFromNamespace(color, "crayon")$bold
  if (is.null(fn)) {
    cat(sep = "", prefix, "* ", style(paste0("No ", type, " function.")), "\n")
  } else {
    cat(sep = "", prefix, "* ", style(paste0(type, " function")), ":\n")
    if (is(fn, "transformation")) {
      ## We delegate the printing work to the transformation.
      print(fn, indent = indent, ..., full = isTRUE(full))
    } else {
      max_lines <- if (isTRUE(full)) Inf else 5L
      cat(crayon::silver(function_snippet(fn, max_lines = max_lines, indent = indent + 1L)), "\n")
    }
  }
}

## This is the general helper used to print both
## `column_transformation` and `multi_column_transformation` objects.
print_transformation <- function(x, ..., indent = 0L, full = FALSE,
                                        byline = "Transformation") {
  prefix <- paste(rep("  ", indent), collapse = "")
  cat(sep = "", prefix, crayon::yellow(byline),
      if (isTRUE(environment(x)$nonstandard)) " with non-standard evaluation", ":")

  ## A little helper function to convert the function `x`
  ## into a character vector of length 1.
  snippet <- function(full. = full) {
    function_snippet(unclass(get("transformation", envir = environment(x))),
                     indent = indent + 1L,
                     max_lines = if (isTRUE(full.)) Inf else 5L)
  }

  ## If the `snippet` generated by trimming long bodies does not equal
  ## the `snippet` generated by printing the full function, show the
  ## user how to print the full body (by passing `full = TRUE` to
  ## `print`).
  if (!isTRUE(full) && !identical(snippet(FALSE), snippet(TRUE))) {
    cat(" use", crayon::bold("print(fn, full = TRUE)"), "to show full body)")
  }

  cat(sep = "", "\n", crayon::silver(snippet()), "\n")
}

## A helper function to turn functions into their string
## representations for convenient printing.
function_snippet <- function(fn, indent = 0L, max_lines = 5L) {
  prefix <- paste(rep("  ", indent), collapse = "")
  ## Note that `utils::head` will convert the function to a string
  ## for us. We use this to get a character representation of the
  ## formals of the function along with its body.
  str_fn <- as.character(utils::head(fn, 10000))
  ## However, `utils::head` uses four spaces per tab instead of two.
  str_fn <- gsub("    ", "  ", str_fn)

  if (!is.call(body(fn)) || !identical(body(fn)[[1L]], as.name("{"))) {
    ## If the function does not have braces `{` surrounding its
    ## body, squish the last two lines into a single line, so e.g.,
    ## `function(x)\n x` becomes `function(x) x`.
    str_fn[length(str_fn) - 1] <-
      c(paste(str_fn[seq(length(str_fn) - 1, length(str_fn))], collapse = ""))
    str_fn <- str_fn[seq_len(length(str_fn) - 1)]
    ## If the function body spills over, trim it.
    if (length(str_fn) > max_lines + 1) {
      str_fn <- c(str_fn[seq_len(max_lines)], paste0("..."))
    }
  } else {
    ## Squish the `{` onto a single line.
    braces <- str_fn == "{"
    ## Note the first line can never be just `{` since it is the formals
    ## of the function.
    str_fn[which(braces) - 1L] <- vapply(str_fn[which(braces) - 1L],
      function(s) paste0(s, "{"), character(1))
    str_fn <- str_fn[!braces]
    ## If the function body spills over, trim it.
    if (length(str_fn) > max_lines + 2) {
      str_fn <- c(str_fn[seq_len(max_lines)], "  # Rest of body...", "}")
    }
  }

  paste(vapply(str_fn, function(s) paste0(prefix, s), character(1)), collapse = "\n")
}

