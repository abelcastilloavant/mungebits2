% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/column_transformation.R
\name{column_transformation}
\alias{column_transformation}
\title{Pure column transformations.}
\usage{
column_transformation(transformation, nonstandard = FALSE)
}
\arguments{
\item{transformation}{function. The function's first argument will
receive an atomic vector derived from some \code{data.frame}. If the
\code{transformation} has a \code{name} argument, it will receive
the column name. Any other arguments will be received as the
\code{list(...)} from calling the function produced by 
\code{column_transformation}.}

\item{nonstandard}{logical. If \code{TRUE}, nonstandard evaluation support
will be provided for the derived function, so it will be possible
to capture the calling expression for each column. By default \code{FALSE}.
Note this will slow the transformation by 0.1ms on each column.}
}
\value{
a function which takes a data.frame and a vector of column
   names (or several other formats, see \code{\link{standard_column_format}})
   and applies the \code{transformation}.
}
\description{
A mungebit which affects multiple columns identically and independently
can be abstracted into a column transformation. This function allows one
to specify what happens to an individual column, and the mungebit will be
the resulting column transformation applied to an arbitrary combination of
columns.
}
\note{
The function produced by calling \code{column_transformation} will
   not run independently. It must be used a train or predict function for
   a \code{\link{mungebit}}.
}
\examples{
doubler <- column_transformation(function(x) { 2 * x })
# doubles the Sepal.Length column in the iris dataset
iris2 <- mungebit$new(doubler)$run(iris, c("Sepal.Length")) 
}
\seealso{
\code{\link{multi_column_transformation}}, \code{\link{standard_column_format}}
}

